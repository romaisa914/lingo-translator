import streamlit as st import json import requests from pathlib import Path # --- Paths --- DATA_DIR = Path(__file__).parent LESSONS_FILE = DATA_DIR / "lessons.json" QUIZZES_FILE = DATA_DIR / "quizzes.json" # --- Load data (cached) --- @st.cache_data def load_lessons(): with open(LESSONS_FILE, "r", encoding="utf-8") as f: return json.load(f) @st.cache_data def load_quizzes(): with open(QUIZZES_FILE, "r", encoding="utf-8") as f: return json.load(f) lessons = load_lessons() quizzes = load_quizzes() lesson_map = {l["lesson_id"]: l for l in lessons} quiz_map = {q["lesson_id"]: q for q in quizzes} # --- session state initialization --- if "completed" not in st.session_state: st.session_state.completed = set() if "chat_history" not in st.session_state: st.session_state.chat_history = [] # list of tuples ("You", msg) or ("Bot", msg) if "chat_input" not in st.session_state: st.session_state.chat_input = "" if "quiz_for" not in st.session_state: st.session_state.quiz_for = None # --- page config --- st.set_page_config(page_title="Lingo Translator", layout="wide") # --- local dictionary (fallback) --- LOCAL_DICT = { "hello": "hallo", "good morning": "guten morgen", "thank you": "danke", "please": "bitte", "goodbye": "auf wiedersehen", "how are you?": "wie geht's?", "i am fine": "mir geht es gut", "see you soon": "bis bald", "yes": "ja", "no": "nein", "excuse me": "entschuldigung", "sorry": "entschuldigung", "my name is": "ich heiÃŸe" } # --- translator helper: try multiple endpoints then fallback --- TRANSLATE_ENDPOINTS = [ "https://libretranslate.com/translate", "https://translate.argosopentech.com/translate" ] def translate_text(text: str, target: str = "de"): text = text.strip() if not text: return {"translated": "", "method": "empty"} # Try endpoints if requests: for url in TRANSLATE_ENDPOINTS: try: resp = requests.post(url, json={ "q": text, "source": "auto", "target": target, "format": "text" }, timeout=8) if resp.ok: data = resp.json() translated = data.get("translatedText") or data.get("translated") or data.get("text") if translated: return {"translated": translated, "method": f"api:{url}"} except Exception: # try next endpoint continue # Fallback to local dictionary if target == "de": translated = LOCAL_DICT.get(text.lower(), None) if translated: return {"translated": translated, "method": "local_dict"} else: return {"translated": "Translation not found in local dictionary.", "method": "local_dict"} else: rev = {v: k for k, v in LOCAL_DICT.items()} translated = rev.get(text.lower(), None) if translated: return {"translated": translated, "method": "local_dict"} else: return {"translated": "Translation not found in local dictionary.", "method": "local_dict"} # ---------- Navigation ---------- page = st.sidebar.selectbox("Navigate", ["Home", "Lessons", "Translator", "Quiz", "Chatbot", "Progress", "Export"]) # ---------- Home ---------- if page == "Home": st.title("ðŸ‡©ðŸ‡ª Lingo Translator â€” Learn German") st.write("A lightweight learning app with lessons, translator, quizzes and a chatbot.") total = len(lessons) completed = len(st.session_state.completed) pct = int((completed / total) * 100) if total else 0 st.metric("Progress", f"{completed}/{total}", delta=f"{pct}%") st.progress(pct) st.write("**Available lessons**") cols = st.columns(3) for i, l in enumerate(lessons): with cols[i % 3]: status = "âœ… Completed" if l["lesson_id"] in st.session_state.completed else "â—»ï¸ Not started" st.subheader(f"Lesson {l['lesson_id']}: {l['title']}") st.write(status) if st.button(f"Open lesson {l['lesson_id']}", key=f"open_{l['lesson_id']}"): st.session_state.quiz_for = None st.session_state._selected_lesson = l["lesson_id"] st.experimental_rerun() # ---------- Lessons ---------- elif page == "Lessons": st.header("ðŸ“š Lessons") lesson_choices = [f"Lesson {l['lesson_id']}: {l['title']}" for l in lessons] sel = st.selectbox("Select a lesson", ["-- choose --"] + lesson_choices) if sel and sel != "-- choose --": lesson_id = int(sel.split()[1].strip(':')) lesson = lesson_map[lesson_id] st.subheader(f"Lesson {lesson_id} â€” {lesson['title']}") st.write("Practice these words/phrases:") for item in lesson["content"]: st.write(f"- **{item['en']}** â†’ *{item['de']}*") cols = st.columns([6,1]) # Add a TTS button inline (browser will do it) if cols[1].button(f"ðŸ”Š {item['de']}", key=f"tts_{lesson_id}_{item['de']}"): st.write("") # placeholder to capture button press; TTS in Streamlit requires st.audio or JS â€“ left simple st.write("") if st.button("Mark lesson complete"): st.session_state.completed.add(lesson_id) st.success("Lesson marked complete âœ…") if st.button("Open lesson quiz"): st.session_state.quiz_for = lesson_id st.experimental_rerun() # ---------- Translator ---------- elif page == "Translator": st.header("ðŸ” Translator") col1, col2 = st.columns([4,1]) with col1: text_input = st.text_input("Enter text to translate", key="translate_input") with col2: direction = st.selectbox("Direction", ["English â†’ German", "German â†’ English"], index=0) target = "de" if direction.startswith("English") else "en" if st.button("Translate"): if not text_input.strip(): st.warning("Type something to translate.") else: with st.spinner("Translating..."): res = translate_text(text_input, target) st.success(res["translated"]) st.caption(f"Method used: {res['method']}") # ---------- Quiz ---------- elif page == "Quiz": st.header("ðŸ§ª Quiz") default_lesson = st.session_state.get("quiz_for", None) quiz_options = [q["lesson_id"] for q in quizzes] sel_id = st.selectbox("Choose lesson quiz", [None] + quiz_options, index=0 if default_lesson is None else quiz_options.index(default_lesson)+1) if sel_id: quiz = quiz_map.get(sel_id) lesson_title = lesson_map[sel_id]["title"] if sel_id in lesson_map else "" st.subheader(f"Quiz â€” Lesson {sel_id} : {lesson_title}") # Create form for questions with st.form(f"quiz_form_{sel_id}"): user_answers = [] for i, q in enumerate(quiz["content"]): q_key = f"q_{sel_id}_{i}" if q["type"] == "mcq": user_ans = st.radio(f"{i+1}. {q['question']}", q["options"], key=q_key) elif q["type"] == "fill": user_ans = st.text_input(f"{i+1}. {q['question']}", key=q_key) elif q["type"] == "truefalse": user_ans = st.selectbox(f"{i+1}. {q['question']}", ["True", "False"], key=q_key) else: user_ans = "" user_answers.append(user_ans) submitted = st.form_submit_button("Submit Quiz") if submitted: score = 0 total = len(quiz["content"]) st.write("---") for i, q in enumerate(quiz["content"]): user_a = user_answers[i] correct_flag = False correct_display = "" if q["type"] == "mcq": correct_display = str(q["answer"]) if str(user_a).strip().lower() == str(q["answer"]).strip().lower(): correct_flag = True elif q["type"] == "fill": correct_display = str(q["answer"]) if str(user_a).strip().lower() == str(q["answer"]).strip().lower(): correct_flag = True elif q["type"] == "truefalse": correct_display = "True" if q["answer"] else "False" if user_a == correct_display: correct_flag = True if correct_flag: score += 1 st.success(f"Q{i+1} Correct â€” {q['question']}") else: st.error(f"Q{i+1} Wrong â€” {q['question']}") st.info(f"Your answer: **{user_a}** â€” Correct answer: **{correct_display}**") st.write("---") st.success(f"Score: {score} / {total}") # mark lesson complete if >= 50% if score/total >= 0.5: st.session_state.completed.add(sel_id) st.info("Lesson marked complete because you passed the quiz âœ…") # ---------- Chatbot ---------- elif page == "Chatbot": st.header("ðŸ¤– German Chatbot") st.write("Simple rule-based chatbot â€” try 'hallo', 'danke', 'hilfe'.") col1, col2 = st.columns([4,1]) # Input in left column, send button in right with col1: # uses session_state so clearing works after send user_msg = st.text_input("You:", key="chat_input", value=st.session_state.get("chat_input", "")) with col2: if st.button("Send"): msg = st.session_state.get("chat_input", "").strip() if msg: m = msg.lower() if "hallo" in m: reply = "Hallo! Wie geht's?" elif "danke" in m: reply = "Gern geschehen!" elif "tschau" in m or "bye" in m: reply = "Auf Wiedersehen!" elif "hilfe" in m: reply = "Ich kann dir bei DeutschÃ¼bungen helfen!" else: reply = "Ich verstehe nicht. Bitte versuche es noch einmal." st.session_state.chat_history.append(("You", msg)) st.session_state.chat_history.append(("Bot", reply)) # clear input st.session_state.chat_input = "" # no experimental_rerun needed; Streamlit will rerun after button click and show updated history # Show history (most recent last) for who, text in st.session_state.chat_history: if who == "You": st.markdown(f"**You:** {text}") else: st.markdown(f"**Bot:** {text}") # ---------- Progress ---------- elif page == "Progress": st.header("ðŸ“ˆ Progress") total = len(lessons) completed = len(st.session_state.completed) pct = int((completed / total) * 100) if total else 0 st.write(f"Lessons completed: **{completed} / {total}** ({pct}%)") st.progress(pct) if st.button("Reset progress"): st.session_state.completed = set() st.success("Progress reset.") # ---------- Export / Import ---------- elif page == "Export": st.header("ðŸ“¤ Export / Import Progress") progress = {"completed": list(st.session_state.completed)} st.download_button("Download progress (JSON)", json.dumps(progress), file_name="progress.json", mime="application/json") uploaded = st.file_uploader("Upload progress JSON to import", type=["json"]) if uploaded: data = json.load(uploaded) comp = data.get("completed", []) st.session_state.completed = set(comp) st.success("Progress imported.")
